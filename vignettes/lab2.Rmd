---
title: "Lab 2: Modeling population dynamics"
subtitle: "WILD3810: Plant and animal populations"
author: "Spring 2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lab2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(WILD3810)
```

***

In this lab, you will learn to model and predict the growth of plant and animal populations using `R`. Continuing from the first lab, you will continue learning how to use `R` to model and visualize changes in abundance over time. 

***

# Modeling exponential population growth

Collared-doves

## Subsetting vectors

## `for` loops

## Visualizing the results

### Data frames

### Intro to `ggplot2()`

# Modeling density-dependent growth

Nutria

## Visualizing the results

dN/dt vs N


In the last lab, we learned about one class of `R` object - vectors. Vectors hold a string of values as a single object.

Perhaps the most common type data object you will use in `R` is the data frame. Data frames are tabular objects (rows and columns) similar in structure to spreadsheets (think Excel or GoogleSheets). In effect, data frames store multiple vectors - each column of the data frame is a vector. As such, each column can be a different class (numeric, character, etc.) but all values within a column must be the same class. Just as the first row of an Excel spreadsheet can be a list of column names, each column in a data frame has a name that (hopefully) provides information about what the values in that column represent. 

To see how data frames work, we can create a simple one using the `data.frame()` function. In this function, we provide the name of each column followed by a vector containing the values of that column. Just like naming vector objects, the column names cannot start with a number and should not contain spaces. 

```{r echo = TRUE}
## Create a data frame 
abundance_df <- data.frame(Year = seq(from = 1972, to = 2015), 
                           N = )
```

Unlike when creating objects (where we use the `<-` operator), you **must** use an equals sign to create each column in a data frame. 

### Brief introduction to `ggplot2`

The power and flexibility of `ggplot2` come from it's consistent structure. Although a bit confusing at first, once you get the hang of it the structure actually makes it quite easy to create highly customized visualizations. All plots created using `ggplot2` use the same underlying structure:

$$\underbrace{ggplot}_{initiate\; plot}(\underbrace{data = df}_{data\;frame},\; \underbrace{aes(x =\; , y = \;)}_{plot\; attributes}) + \underbrace{geom\_line()}_{geometry}$$

The `ggplot()` function initiates a new plot. In this function, you tell `ggplot2` what data frame you will be using for the plot and you tell it how to map attributes of the data to the visual properties of the figures. Attributes are mapped inside the `aes()` argument. Attributes usually include location (`x-axis` and `y-axis` placement), color, size, shape, line type, and many others. In general, each attribute will be mapped to one column of your data frame. 

The `ggplot()` function simply initiates a graph - if you run just that portion of the code you will get a blank graph. We can see that by creating a new plot showing the relationship between year (the x-axis of the plot) and abundance (the y-axis): 

```{r fig.width=6, fig.height=6}
ggplot(data = sim_df, aes(x = elevation, y = lambda))
```

You can see that `ggplot` created a figure with the correct axes and labels. But no data. That's because we didn't tell `ggplot` what type of *geometry* to use to represent the data. Geometry refers to the  type geometric object(s) we want to use to display the data. Common geometries include points (e.g., scatterplot), lines (e.g., timeseries), and bars (e.g., histograms). There are many others. Once we add a geometry, we can see the data:

```{r fig.width=6, fig.height=6}
ggplot(data = sim_df, aes(x = elevation, y = lambda)) + geom_point()
```

Going back to the `aes()` argument, we can use other attributes to disply additional information in our graph. For example, we could also show the rainfall at each location by scaling the size of the points to the rainfall: 

```{r fig.width=6, fig.height=6}
ggplot(data = sim_df, aes(x = elevation, y = lambda, size = rainfall)) + geom_point()
```

So we can see that our model predicts abundances ranging from `r min(sim_df$lambda)` individuals to `r max(sim_df$lambda)` individuals. Is that reasonable? Who knows, this is a made up species. But it wasn't, this would be a good time to go back and play with different parameter values to generate abundances that are consistent with our domain expertise. 

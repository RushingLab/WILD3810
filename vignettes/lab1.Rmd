---
title: "Lab 1: Introduction to mark-recapture - estimating abundance"
subtitle: "WILD3810: Plant and animal populations"
author: "Spring 2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lab1}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this lab, we will continue learning how to use `R` to create and manipulate objects, with a particular focus on estimating abundance using the Lincoln-Peterson estimator. 

***
**Objectives**

* Learn/review basic data types, including:  
    + Scalars
    + Vectors
    + Numeric objects
    + Character objects
    
* Learn/review basic data manipulation tasks, including:  
    + Vector algebra
  
  
* `R` functions used in this exercise:  
    + `prod()`
    + `round()`
    + `c()`
    + `sum()`


***

# Set up

1) Log in to R Studio Cloud

2) Create a new project called `LastnameFirstname-Lab1`

3) Create a new R script file to store code from this lab:

    3a) Click `File -> New File -> R Script`
    
    3b) Save the script as `Lab1`
    
## The Lincoln-Peterson estimator

Let's use this new script to better understand the Lincoln-Peterson that we learned about in lecture 2.  

Remember that the Lincoln-Peterson method is used to estimate the abundance of a closed population using mark-recapture data. As a reminder, the Lincoln-Peterson estimator is:

$$N = \frac{n_1n_2}{m_2}$$

where $n_1$ is the number of individuals captured (and marked) on the first sampling occasion, $n_2$ is the number of individuals captured on the second sampling occasion, and $m_2$ is the number of marked individuals in the second sample. 

Let's use `R`to estimate N for some made up data. In the script you just opened, create three new objects that represent the parameters in the Lincoln-Peterson estimator. Modify the following code to tell `R`that we captured 44 individuals on the first occasion, 32 on the second, and of those 32 sampled on the second occasion, 15 were marked:

```{r echo=TRUE, eval = FALSE}
n1 <-

n2 <-
  
m2 <- 
```

After entering the code, highlight all three lines and then click `Ctrl + Enter` (or `command + return` on Mac) to run the code. Note that you should see the code in the console.  

Now add a new line of code (put your cursor at the end of the `m2 <-` line and hit enter) and estimate $N$ from our newly created objects using the Lincoln-Peterson: 

```{r echo = TRUE, eval = FALSE}
N <- n1 * n2 / m2
```

## Built-in functions

The power of `R` is most apparent in the large number of built-in functions that are available for users.  
Functions are small bits of code that perform a specific task. Most functions accept one or more inputs called arguments and return a value or a new object.  

In the Lincoln-Peterson example, rather than typing `n1 * n2` we could use the function `prod()`. Prod takes as arguments 2 or more numbers (separated by commas) and returns the product:

```{r product, echo=TRUE}
n1 <- 44     # Number of individuals captured on first occasion

n2 <- 32     # Number of individuals captured on second occasion

numerator <- prod(n1, n2)
numerator
```

Here, we provided `n1` and `n2` are arguments and `prod` created a new object called `numerator` which is the product of our two value. It may seem silly to use a function in this case (it didn't save us much work afterall) but this type of function can be useful if you had a longer set of values and didn't want to type them manually to get the product

### Built-in functions

Every function takes a different set of arguments and in most cases you will need to look what those arguments are. The best way to get help for a specific function is to type a question mark followed by the function name, which will bring up a help page in the bottom right panel. For example, the `round` function rounds a number to a specified number of decimal places. This is a useful function when we don't want to print a really large number of digits (like our L-P estimate of $N$):

```{r help, eval = FALSE, echo = TRUE}
?round
```

So we see `round` takes an argument called `x`, which is the number we want to round, and the number of `digits` we want to round to. If you provide the arguments in the exact same order as they are defined you don’t have to name them. For example, :

```{r include = FALSE}
m2 <- 15
```

```{r round, eval = TRUE, echo = TRUE}
N <- prod(n1, n2)/m2
N

round(N, 0)
```

If you do name the arguments, you can switch their order:

```{r round2, eval = TRUE, echo = TRUE}
round(digits = 0, x = N)
```

Although you don't have to name arguments, it’s a good idea to get in the habit of naming them. This will make you code easier to read, will help avoid mistakes that can occur when you don't put the arguments in the correct order, and makes it easier to trouble shoot code that doesn't do what you expect it to do. 

## Commenting your code

R will ignore any code that follows a `#`. This is *very* useful for making your code more readable for both yourself and others. Use comments to remind yourself what a newly created object is, to explain what a line of code does, to leave yourself a reminder for later, etc. For example, in the previous code, it might be a good idea to use comments to define what each object represents:

```{r LP_comment, echo = TRUE}
n1 <- 44     # Number of individuals captured on first occasion

n2 <- 32     # Number of individuals captured on second occasion
  
m2 <- 15     # Number of previously marked individuals captured on second occasion
```

Notice that when you run this code, `R`ignores the comments. 

# Vectors

So far, we have only been working with objects that store a single number. However, often it is more convienient to store a string of numbers as a single object. In `R`, these strings are called *vectors* and they are created by enclosing the string between `c(` and `)`:

```{r echo = TRUE}
x <- c(3,5,2,5)
x
```

A vector can also contain characters (though you cannot mix numbers and charactors in the same vector!):

```{r echo = TRUE}
occasions <- c("Occasion1", "Occasion2", "Occasion3")
occasions
```

The quotes around “Occasion1”, “Occasion2”, and "Occasion3" are critical. Without the quotes `R` will assume there are objects called `Occasion1`, `Occasion2` and `Occasion3`. As these objects don’t exist in `R`’s memory, there will be an error message.  

Vectors can be any length (including 1. In fact, the numeric objects we've been working with are just vectors with length 1). The function `length()` tells you how long a vector is:

```{r echo = TRUE}
length(x)
```

The function `class()` indicates the class (the type of element) of an object:

```{r echo = TRUE}
class(x)
class(occasions)
```

What is the class of a vector with both numeric and characters entries? Hint:

```{r echo = TRUE}
mixed <- c(1, 2, "3", "4")
```

You can also use the `c()` function to add other elements to your vector:

```{r echo = TRUE}
y <- c(x, 4,8,3)
```

Vectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame), factors (factor) and arrays (array). We will learn about each of those data structures as we encounter them in our exercises. 

# Exercise 2: The Schnabel method

To better understand how we use vectors in `R` and to expand on our discussion of abundance estimation, we will learn how to use the **Schnabel method** to estimate $N$.  

In many studies, researchers attempt to resight marked individuals on more than 2 occasions. Unfortunatley, the Lincoln-Peterson method is restricted to data from only 2 capture occasions, meaning that to use it, we have to throw out data from occasions $3,4,...,T$.   

In the 1930's, a mathmetician at the University of Wisconsin named Zoe Emily Schnabel, expanded on the Lincoln-Peterson method to include $>2$ occasions. The Schnabel method uses three pieces of information collected at each occassion: **$C_t$**, the number of captured individuals during occasion $t$; **$R_t$**, the number of recaptures captured during occasion $t$; and **$M_t$**, the number of individuals marked in the population at occasion $t$ (or, the total number of marked individuals at risk of being captured on occasion $t$). Using these data, the Schnabel estimator is:

$$\hat{N} = \frac{\sum_t(C_t \times M_t)}{\sum_t R_t}$$
*Remember that $\sum_t$ means the sum of the values across at $T$ occasions.*

To better understand what each of these data mean, we will use an example from [Powell & Gale (2015)](http://docs.wixstatic.com/ugd/95e73b_6d832c61405d4b3cbd9d99bbb4530f7b.pdf) (pages 96-97). Students on a research trip to Puerto Rico did a 3-day mark-recapture study to estimate the number of Cuban rock iguanas (*Cyclura nubila*) on the island Isla Magueyes. On the first day, the students observed and marked (using latex paint) 155 iguanas. On the second day, they observed 175 individuals (109 marked and 66 unmarked; note that the 66 unmarked individuals were captured, marked, and released). On the third day, they observed 131 individuals (116 marked and 15 unmarked).

```{r iguanas, echo = FALSE}
library(kableExtra)
iguanas <- data.frame(Day = c(1,2,3),
                      C = c(155, 175, 131),
                      R = c(0, 109, 116))

iguanas %>%
  kable("html", col.names = c("Day", "Animals Observed", "Animal with marks"), align = 'c') %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = TRUE)

```

In this example, $C_t =$

```{r echo = TRUE}
Ct <- c(155, 175, 131) # Number of captures during each occassion
```

and $R_t =$

```{r echo = TRUE}
Rt <- c(0, 109, 116) # Number of recaptures during each occassion
```

What is $M_t$? On the first day, there are no previously marked individuals so $M_1=0$. On the second day, there are 155 marked individuals in the population (all of the individuals marked on day 1) so $M_2=155$. On day 3, the students could have observed individuals marked on the first day or individuals marked on the second day ($175-109=66$ individuals marked on day 2) so $M_3 = 155 + 66 = 221$. So:

```{r echo = TRUE}
Mt <- c(0, 155, 221) # Number of recaptures during each occassion
```

Now to estimate $\hat{N}$. We *could* do it by hand:

```{r eval = FALSE}

N <- ((155*0) + (175 * 155) + (131 * 221)) / (0 + 109 + 116)

```

However, that is *a lot* of typing and it's pretty likely we would make a mistake somewhere along the way (typos or misplaced parentheses). `R` is clever enough to allow us to use the previously created vectors. First, let's see what happens when we multiply two vectors together:

```{r echo = TRUE}
Ct * Mt
```

As you can see, we created a new vector that is the same length as the original vectors (3). When you mutiply (or add, subtract, or divide) two vectors, `R` multiplies the first element of first vector times the first element of the second vector, the second element of first vector times the second element of the second vector, the third element of first vector times the third element of the second vector, etc, and then combines them into a new vector. 

We can also use the `sum()` function to add up all of the elements of a vector (similar to the `prod()` function we saw earlier). So:

```{r echo = TRUE}
N <- sum(Ct * Mt) / sum(Rt)
round(x = N, digits = 0)
```

Much easier! 

## Properties of the Lincoln-Peterson estimator

In the next homework, we will use `R` to better understand the properties of the LP estimator. To create this homework:

1) Create a new R Markdown file from the Homework-1 template:

    1a) Click `File -> New File -> R Markdown`  
    
    1b) Click `From Template` and scroll down to `WILD3810-Homework1`  
    
    1c) In the `Name` box, type `LastnameFirstname-Homework1`  
    
    1d) Click `Ok`

2) Ensure that you can `Knit` the file

    2a) Change "YOUR NAME HERE" in the header section to your name  
    
    2b) Click `Knit` to make sure you can knit the .Rmd file  
    
3) Complete the assignment as directed in the .Rmd file

4) Follow the [instructions for submission](https://rushinglab.github.io/WILD3810/articles/homework.html) to upload your completed assignment to Canvas

